<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Performance Comparison</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin: 30px 0;
        }
        
        .chart {
            display: flex;
            height: 350px;
            align-items: flex-end;
            justify-content: center;
            padding: 0 20px;
        }
        
        .bar {
            margin: 0 20px;
            width: 80px;
            background-color: #3498db;
            position: relative;
            transition: height 1.5s ease-in-out;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }
        
        .bar-label {
            margin-top: 10px;
            font-weight: bold;
        }
        
        .time-label {
            position: absolute;
            top: -30px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
        }
        
        .explanation {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin: 30px 0;
            text-align: left;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        
        button {
            padding: 10px 20px;
            margin: 0 10px;
            background-color: #2980b9;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background-color: #3498db;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .y-axis {
            position: absolute;
            left: 10px;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
        }
        
        .y-axis-label {
            font-size: 12px;
            margin-right: 5px;
        }
        
        .big-o {
            font-style: italic;
            font-weight: bold;
        }
        
        .step-info {
            margin-top: 20px;
            font-weight: bold;
        }
        
        .complexity-label {
            font-size: 14px;
            margin-top: 5px;
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <h1>Sorting Algorithm Performance Comparison</h1>
    
    <div class="explanation" id="explanation">
        <p>This animation compares the average performance of common sorting algorithms when sorting an array of 1000 elements.</p>
        <p>We'll see how algorithms with different time complexities perform:</p>
        <ul>
            <li>Bubble Sort, Selection Sort, Insertion Sort - <span class="big-o">O(n²)</span> complexity</li>
            <li>Merge Sort, Quick Sort - <span class="big-o">O(n log n)</span> complexity</li>
        </ul>
    </div>
    
    <div class="step-info" id="stepInfo">Step 1: Setting up comparison</div>
    
    <div class="chart-container">
        <div class="y-axis">
            <div class="y-axis-label">1000 ms</div>
            <div class="y-axis-label">750 ms</div>
            <div class="y-axis-label">500 ms</div>
            <div class="y-axis-label">250 ms</div>
            <div class="y-axis-label">0 ms</div>
        </div>
        <div class="chart" id="chart">
            <div class="bar" id="bubble" style="height: 0;">
                <div class="time-label" id="bubbleTime"></div>
                <div class="complexity-label">O(n²)</div>
                <div class="bar-label">Bubble Sort</div>
            </div>
            <div class="bar" id="insertion" style="height: 0;">
                <div class="time-label" id="insertionTime"></div>
                <div class="complexity-label">O(n²)</div>
                <div class="bar-label">Insertion Sort</div>
            </div>
            <div class="bar" id="selection" style="height: 0;">
                <div class="time-label" id="selectionTime"></div>
                <div class="complexity-label">O(n²)</div>
                <div class="bar-label">Selection Sort</div>
            </div>
            <div class="bar" id="quick" style="height: 0;">
                <div class="time-label" id="quickTime"></div>
                <div class="complexity-label">O(n log n)</div>
                <div class="bar-label">Quick Sort</div>
            </div>
            <div class="bar" id="merge" style="height: 0;">
                <div class="time-label" id="mergeTime"></div>
                <div class="complexity-label">O(n log n)</div>
                <div class="bar-label">Merge Sort</div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="prevBtn" disabled>Previous</button>
        <button id="nextBtn">Next</button>
    </div>
    
    <script>
        const steps = [
            {
                explanation: "This animation compares the average performance of common sorting algorithms when sorting an array of 1000 elements.",
                heights: {
                    bubble: 0,
                    insertion: 0,
                    selection: 0,
                    quick: 0,
                    merge: 0
                },
                opacities: {
                    bubble: 0,
                    insertion: 0,
                    selection: 0,
                    quick: 0,
                    merge: 0
                },
                stepInfo: "Step 1: Setting up comparison"
            },
            {
                explanation: "Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they're in the wrong order. For 1000 elements, it must make nearly 1,000,000 comparisons in the worst case!",
                heights: {
                    bubble: 300,
                    insertion: 0,
                    selection: 0,
                    quick: 0,
                    merge: 0
                },
                opacities: {
                    bubble: 1,
                    insertion: 0,
                    selection: 0,
                    quick: 0,
                    merge: 0
                },
                times: {
                    bubble: "980 ms"
                },
                stepInfo: "Step 2: Bubble Sort Performance"
            },
            {
                explanation: "Insertion Sort builds the final sorted array one item at a time. Like Bubble Sort, it also has O(n²) complexity, but with better constants, making it somewhat faster for small arrays.",
                heights: {
                    bubble: 300,
                    insertion: 250,
                    selection: 0,
                    quick: 0,
                    merge: 0
                },
                opacities: {
                    bubble: 1,
                    insertion: 1,
                    selection: 0,
                    quick: 0,
                    merge: 0
                },
                times: {
                    bubble: "980 ms",
                    insertion: "810 ms"
                },
                stepInfo: "Step 3: Insertion Sort Performance"
            },
            {
                explanation: "Selection Sort divides the array into a sorted and an unsorted region. It repeatedly selects the smallest element from the unsorted region and moves it to the sorted region. Like the previous two, it has O(n²) complexity.",
                heights: {
                    bubble: 300,
                    insertion: 250,
                    selection: 270,
                    quick: 0,
                    merge: 0
                },
                opacities: {
                    bubble: 1,
                    insertion: 1,
                    selection: 1,
                    quick: 0,
                    merge: 0
                },
                times: {
                    bubble: "980 ms",
                    insertion: "810 ms",
                    selection: "890 ms"
                },
                stepInfo: "Step 4: Selection Sort Performance"
            },
            {
                explanation: "Quick Sort uses a divide-and-conquer strategy. It picks an element as a pivot and partitions the array around it. Its O(n log n) average complexity makes it much faster for large arrays than the O(n²) algorithms we've seen so far.",
                heights: {
                    bubble: 300,
                    insertion: 250,
                    selection: 270,
                    quick: 65,
                    merge: 0
                },
                opacities: {
                    bubble: 1,
                    insertion: 1,
                    selection: 1,
                    quick: 1,
                    merge: 0
                },
                times: {
                    bubble: "980 ms",
                    insertion: "810 ms",
                    selection: "890 ms",
                    quick: "70 ms"
                },
                stepInfo: "Step 5: Quick Sort Performance"
            },
            {
                explanation: "Merge Sort also uses divide-and-conquer. It divides the array in half, sorts each half, then merges them back together. With O(n log n) complexity, it's also much faster than O(n²) algorithms for large datasets.",
                heights: {
                    bubble: 300,
                    insertion: 250,
                    selection: 270,
                    quick: 65,
                    merge: 80
                },
                opacities: {
                    bubble: 1,
                    insertion: 1,
                    selection: 1,
                    quick: 1,
                    merge: 1
                },
                times: {
                    bubble: "980 ms",
                    insertion: "810 ms",
                    selection: "890 ms",
                    quick: "70 ms",
                    merge: "90 ms"
                },
                stepInfo: "Step 6: Merge Sort Performance"
            },
            {
                explanation: "As we can clearly see, the O(n²) algorithms (Bubble, Insertion, and Selection Sort) perform much worse than the O(n log n) algorithms (Quick Sort and Merge Sort) for large arrays. For 1000 elements, the difference is dramatic - around 10 times slower! This difference becomes even more pronounced as the array size increases.",
                heights: {
                    bubble: 300,
                    insertion: 250,
                    selection: 270,
                    quick: 65,
                    merge: 80
                },
                opacities: {
                    bubble: 1,
                    insertion: 1,
                    selection: 1,
                    quick: 1,
                    merge: 1
                },
                times: {
                    bubble: "980 ms",
                    insertion: "810 ms",
                    selection: "890 ms",
                    quick: "70 ms",
                    merge: "90 ms"
                },
                stepInfo: "Step 7: Performance Comparison"
            }
        ];
        
        let currentStep = 0;
        const nextBtn = document.getElementById('nextBtn');
        const prevBtn = document.getElementById('prevBtn');
        const explanationDiv = document.getElementById('explanation');
        const stepInfoDiv = document.getElementById('stepInfo');
        
        function updateUI() {
            const step = steps[currentStep];
            
            // Update bar heights
            for (const algo in step.heights) {
                const bar = document.getElementById(algo);
                bar.style.height = step.heights[algo] + 'px';
                
                // Update time labels
                const timeLabel = document.getElementById(`${algo}Time`);
                if (step.times && step.times[algo]) {
                    timeLabel.textContent = step.times[algo];
                }
                timeLabel.style.opacity = step.opacities[algo];
            }
            
            // Update explanation
            explanationDiv.innerHTML = `<p>${step.explanation}</p>`;
            if (currentStep === 0) {
                explanationDiv.innerHTML += `
                <p>We'll see how algorithms with different time complexities perform:</p>
                <ul>
                    <li>Bubble Sort, Selection Sort, Insertion Sort - <span class="big-o">O(n²)</span> complexity</li>
                    <li>Merge Sort, Quick Sort - <span class="big-o">O(n log n)</span> complexity</li>
                </ul>
                `;
            }
            
            // Update step info
            stepInfoDiv.textContent = step.stepInfo;
            
            // Update button states
            prevBtn.disabled = currentStep === 0;
            nextBtn.disabled = currentStep === steps.length - 1;
        }
        
        nextBtn.addEventListener('click', () => {
            if (currentStep < steps.length - 1) {
                currentStep++;
                updateUI();
            }
        });
        
        prevBtn.addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                updateUI();
            }
        });
        
        // Initialize the UI
        updateUI();
    </script>
</body>
</html>