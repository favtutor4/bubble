<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Sort Time Complexity</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
        }
        .container {
            width: 90%;
            max-width: 800px;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        .canvas-container {
            width: 100%;
            margin: 20px 0;
            position: relative;
        }
        canvas {
            width: 100%;
            border: 1px solid #ddd;
            background-color: white;
        }
        .explanation {
            margin: 20px 0;
            line-height: 1.6;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .legend {
            display: flex;
            justify-content: center;
            margin: 15px 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 3px;
        }
        .slider-container {
            width: 100%;
            margin: 20px 0;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Time Complexity of Bubble Sort</h1>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Array Size (n): <span id="size-value">10</span></span>
            </div>
            <input type="range" id="size-slider" min="5" max="50" value="10">
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #27ae60;"></div>
                <span>O(n) - Best Case (Sorted Array)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e74c3c;"></div>
                <span>O(n²) - Worst Case (Reverse Sorted)</span>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="graph" height="400"></canvas>
        </div>
        
        <div class="explanation" id="explanation">
            <div id="slide1">
                <h3>What is Time Complexity?</h3>
                <p>Time complexity measures how the runtime of an algorithm grows as the input size increases. For Bubble Sort, we analyze how the number of operations changes with different array sizes.</p>
                <p>The graph shows two key scenarios for Bubble Sort:</p>
                <ul>
                    <li>Best Case (Green Line): O(n) - When the array is already sorted</li>
                    <li>Worst Case (Red Line): O(n²) - When the array is sorted in reverse</li>
                </ul>
            </div>
            
            <div id="slide2" style="display: none;">
                <h3>Best Case: O(n)</h3>
                <p>When the array is already sorted, Bubble Sort can be optimized to run in O(n) time.</p>
                <p>In this case:</p>
                <ul>
                    <li>The algorithm only needs to make a single pass through the array</li>
                    <li>No swaps are needed since everything is in order</li>
                    <li>With an optimization flag, the algorithm can detect this and stop early</li>
                </ul>
                <p>Notice how the green line grows linearly - doubling the array size approximately doubles the operations.</p>
            </div>
            
            <div id="slide3" style="display: none;">
                <h3>Worst Case: O(n²)</h3>
                <p>When the array is sorted in reverse order (largest to smallest), Bubble Sort performs the maximum number of comparisons and swaps.</p>
                <p>In this case:</p>
                <ul>
                    <li>For each element (n), we need to compare and potentially swap with almost every other element</li>
                    <li>This results in approximately n × n operations</li>
                    <li>The algorithm must make n passes through the array</li>
                </ul>
                <p>See how the red curve grows much faster - doubling the array size quadruples the operations!</p>
            </div>
            
            <div id="slide4" style="display: none;">
                <h3>Why This Matters</h3>
                <p>Understanding time complexity helps us choose the right algorithm for our needs:</p>
                <ul>
                    <li>For small arrays or nearly-sorted data, Bubble Sort might be sufficient</li>
                    <li>For larger datasets, O(n²) algorithms like Bubble Sort become impractical</li>
                    <li>The dramatic difference between best and worst cases shows why data arrangement matters</li>
                </ul>
                <p>Try adjusting the array size slider to see how quickly the worst-case complexity grows compared to the best case!</p>
            </div>
        </div>
        
        <div class="controls">
            <button id="prev-btn" disabled>Previous</button>
            <button id="next-btn">Next</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        const sizeSlider = document.getElementById('size-slider');
        const sizeValue = document.getElementById('size-value');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        let currentSlide = 1;
        const totalSlides = 4;
        let maxSize = parseInt(sizeSlider.value);
        
        // Update the slides
        function updateSlide() {
            for (let i = 1; i <= totalSlides; i++) {
                document.getElementById(`slide${i}`).style.display = i === currentSlide ? 'block' : 'none';
            }
            
            prevBtn.disabled = currentSlide === 1;
            nextBtn.disabled = currentSlide === totalSlides;
        }
        
        // Navigate to previous slide
        prevBtn.addEventListener('click', () => {
            if (currentSlide > 1) {
                currentSlide--;
                updateSlide();
            }
        });
        
        // Navigate to next slide
        nextBtn.addEventListener('click', () => {
            if (currentSlide < totalSlides) {
                currentSlide++;
                updateSlide();
            }
        });
        
        // Update the graph based on array size
        function updateGraph() {
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height;
            const padding = 50;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw axes
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw axes labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            
            // X-axis label
            ctx.fillText('Array Size (n)', width / 2, height - 10);
            
            // Y-axis label (rotated)
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Number of Operations', 0, 0);
            ctx.restore();
            
            // Draw x-axis ticks and values
            const xStep = (width - 2 * padding) / 5;
            for (let i = 0; i <= 5; i++) {
                const x = padding + i * xStep;
                const value = Math.round(maxSize * i / 5);
                
                ctx.beginPath();
                ctx.moveTo(x, height - padding);
                ctx.lineTo(x, height - padding + 5);
                ctx.stroke();
                
                ctx.fillText(value, x, height - padding + 20);
            }
            
            // Calculate max operations for worst case (n²)
            const maxOperations = maxSize * maxSize;
            
            // Draw y-axis ticks and values
            const yStep = (height - 2 * padding) / 5;
            for (let i = 0; i <= 5; i++) {
                const y = height - padding - i * yStep;
                const value = Math.round(maxOperations * i / 5);
                
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding - 5, y);
                ctx.stroke();
                
                ctx.textAlign = 'right';
                ctx.fillText(value, padding - 10, y + 5);
            }
            
            // Plot best case O(n) - Already sorted
            ctx.beginPath();
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 3;
            
            for (let n = 0; n <= maxSize; n++) {
                const operations = n; // O(n) -> single pass through array
                const x = padding + (n / maxSize) * (width - 2 * padding);
                const y = height - padding - (operations / maxOperations) * (height - 2 * padding);
                
                if (n === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Plot worst case O(n²) - Reverse sorted
            ctx.beginPath();
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            
            for (let n = 0; n <= maxSize; n++) {
                const operations = n * n; // O(n²)
                const x = padding + (n / maxSize) * (width - 2 * padding);
                const y = height - padding - (operations / maxOperations) * (height - 2 * padding);
                
                if (n === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Animate the growth difference
            animatePoint();
        }
        
        // Function to animate a point moving along both curves
        let animationFrame;
        function animatePoint() {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            let t = 0;
            let speed = 0.01;
            const maxOperations = maxSize * maxSize;
            
            function draw() {
                if (t <= 1) {
                    // Clear only the points area (not the whole graph)
                    ctx.clearRect(0, 0, width, padding); // Clear the top area for markers
                    
                    const n = t * maxSize;
                    
                    // Best case point
                    const bestOps = n;
                    const bestX = padding + (n / maxSize) * (width - 2 * padding);
                    const bestY = height - padding - (bestOps / maxOperations) * (height - 2 * padding);
                    
                    // Worst case point
                    const worstOps = n * n;
                    const worstX = padding + (n / maxSize) * (width - 2 * padding);
                    const worstY = height - padding - (worstOps / maxOperations) * (height - 2 * padding);
                    
                    // Draw best case point
                    ctx.beginPath();
                    ctx.fillStyle = '#27ae60';
                    ctx.arc(bestX, bestY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw worst case point
                    ctx.beginPath();
                    ctx.fillStyle = '#e74c3c';
                    ctx.arc(worstX, worstY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Show values
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`n=${Math.round(n)}, Ops≈${Math.round(bestOps)}`, bestX, bestY - 10);
                    ctx.fillText(`n=${Math.round(n)}, Ops≈${Math.round(worstOps)}`, worstX, worstY - 10);
                    
                    t += speed;
                    animationFrame = requestAnimationFrame(draw);
                } else {
                    // Restart animation after a pause
                    setTimeout(() => {
                        t = 0;
                        animationFrame = requestAnimationFrame(draw);
                    }, 2000);
                }
            }
            
            animationFrame = requestAnimationFrame(draw);
        }
        
        // Initialize
        function init() {
            sizeSlider.addEventListener('input', () => {
                maxSize = parseInt(sizeSlider.value);
                sizeValue.textContent = maxSize;
                updateGraph();
            });
            
            // Handle window resize
            window.addEventListener('resize', updateGraph);
            
            // Initial render
            updateSlide();
            updateGraph();
        }
        
        init();
    </script>
</body>
</html>