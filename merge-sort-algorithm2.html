<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Sort Execution Tree Animation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
        }
        
        .container {
            width: 900px;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
        }
        
        .visualization {
            margin: 20px 0;
            height: 500px;
            position: relative;
            overflow: hidden;
        }
        
        .explanation {
            margin: 20px 0;
            padding: 15px;
            background-color: #f0f8ff;
            border-radius: 8px;
            border-left: 4px solid #4682b4;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        button {
            padding: 10px 20px;
            margin: 0 10px;
            background-color: #4682b4;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #36648b;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .step-indicator {
            text-align: center;
            font-weight: bold;
            margin: 10px 0;
        }
        
        /* SVG styles */
        svg {
            width: 100%;
            height: 100%;
        }
        
        .node circle {
            fill: #fff;
            stroke: #4682b4;
            stroke-width: 2px;
        }
        
        .node text {
            font-size: 14px;
            font-family: Arial, sans-serif;
        }
        
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }
        
        .arrow {
            fill: #ccc;
        }
        
        .highlight {
            fill: #ff9900;
            stroke: #ff6600;
        }
        
        .highlight-text {
            fill: #ff6600;
            font-weight: bold;
        }
        
        .merged {
            fill: #90ee90;
            stroke: #2e8b57;
        }
        
        .merged-text {
            fill: #2e8b57;
            font-weight: bold;
        }
        
        .dividing {
            stroke: #ff6600;
            stroke-dasharray: 5;
            animation: dash 1s linear infinite;
        }
        
        .merging {
            stroke: #2e8b57;
            stroke-dasharray: 5;
            animation: dash 1s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: 10;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Merge Sort Execution Tree</h1>
        
        <div class="visualization" id="visualization"></div>
        
        <div class="explanation" id="explanation">
            Welcome to the Merge Sort visualization! Click "Next" to begin.
        </div>
        
        <div class="step-indicator" id="step-indicator">Step 0 of 9</div>
        
        <div class="controls">
            <button id="prevBtn" disabled>Previous</button>
            <button id="nextBtn">Next</button>
        </div>
    </div>

    <script>
        const steps = [
            {
                title: "Initial Array",
                explanation: "We start with the unsorted array [38, 27, 43, 3, 9]. Merge sort will divide this array into smaller subarrays until each subarray contains only one element, then merge them back together in sorted order."
            },
            {
                title: "Divide Phase - First Split",
                explanation: "In the first step of the divide phase, we split the array into two halves: [38, 27, 43] and [3, 9]. This is the beginning of the recursive process."
            },
            {
                title: "Divide Phase - Second Split Left",
                explanation: "We continue splitting the left subarray [38, 27, 43] into [38] and [27, 43]. Notice how we keep dividing until we can't divide any further."
            },
            {
                title: "Divide Phase - Second Split Right",
                explanation: "Similarly, we split the right subarray [3, 9] into individual elements [3] and [9]. The arrows pointing downward represent the divide phase."
            },
            {
                title: "Divide Phase - Final Split",
                explanation: "We split [27, 43] into individual elements [27] and [43]. Now all elements are in their own subarrays, which means they are trivially sorted."
            },
            {
                title: "Merge Phase - First Merge",
                explanation: "We begin the merge phase by merging [27] and [43] into the sorted subarray [27, 43]. When merging, we compare elements from both subarrays and place them in order."
            },
            {
                title: "Merge Phase - Second Merge Left",
                explanation: "Now we merge [38] and [27, 43] to get [27, 38, 43]. We compare the first elements of each array and take the smaller one first, continuing until all elements are merged."
            },
            {
                title: "Merge Phase - Second Merge Right",
                explanation: "We merge [3] and [9] to get [3, 9]. Since these elements are already in order, the merge is straightforward."
            },
            {
                title: "Merge Phase - Final Merge",
                explanation: "In the final merge step, we combine [27, 38, 43] and [3, 9] to produce the fully sorted array [3, 9, 27, 38, 43]. The upward arrows represent the merge phase, where smaller sorted arrays are combined into larger sorted arrays."
            }
        ];
        
        let currentStep = 0;
        const totalSteps = steps.length;
        
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const explanationDiv = document.getElementById('explanation');
        const stepIndicator = document.getElementById('step-indicator');
        const visualizationDiv = document.getElementById('visualization');
        
        // Initialize the visualization
        updateVisualization();
        
        prevBtn.addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                updateVisualization();
                updateButtons();
            }
        });
        
        nextBtn.addEventListener('click', () => {
            if (currentStep < totalSteps - 1) {
                currentStep++;
                updateVisualization();
                updateButtons();
            }
        });
        
        function updateButtons() {
            prevBtn.disabled = currentStep === 0;
            nextBtn.disabled = currentStep === totalSteps - 1;
        }
        
        function updateVisualization() {
            explanationDiv.innerHTML = `<strong>${steps[currentStep].title}:</strong> ${steps[currentStep].explanation}`;
            stepIndicator.textContent = `Step ${currentStep + 1} of ${totalSteps}`;
            
            // Clear previous visualization
            visualizationDiv.innerHTML = '';
            
            // Create SVG element
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            visualizationDiv.appendChild(svg);
            
            // Draw the tree based on current step
            drawMergeSortTree(svg, currentStep);
        }
        
        function drawMergeSortTree(svg, step) {
            // Define tree structure
            const treeData = {
                level0: { 
                    node: { x: 450, y: 50, text: "[38, 27, 43, 3, 9]" },
                    state: step >= 0 ? 'visible' : 'hidden'
                },
                level1Left: { 
                    node: { x: 300, y: 130, text: "[38, 27, 43]" },
                    state: step >= 1 ? 'visible' : 'hidden',
                    link: { source: { x: 450, y: 50 }, target: { x: 300, y: 130 } },
                    arrow: step >= 1 && step < 6 ? 'dividing' : (step >= 6 ? 'merging' : 'hidden')
                },
                level1Right: { 
                    node: { x: 600, y: 130, text: "[3, 9]" },
                    state: step >= 1 ? 'visible' : 'hidden',
                    link: { source: { x: 450, y: 50 }, target: { x: 600, y: 130 } },
                    arrow: step >= 1 && step < 7 ? 'dividing' : (step >= 7 ? 'merging' : 'hidden')
                },
                level2LeftLeft: { 
                    node: { x: 200, y: 210, text: "[38]" },
                    state: step >= 2 ? 'visible' : 'hidden',
                    link: { source: { x: 300, y: 130 }, target: { x: 200, y: 210 } },
                    arrow: step >= 2 && step < 6 ? 'dividing' : (step >= 6 ? 'merging' : 'hidden')
                },
                level2LeftRight: { 
                    node: { x: 400, y: 210, text: "[27, 43]" },
                    state: step >= 2 ? 'visible' : 'hidden',
                    link: { source: { x: 300, y: 130 }, target: { x: 400, y: 210 } },
                    arrow: step >= 2 && step < 4 ? 'dividing' : (step >= 5 ? 'merging' : 'hidden')
                },
                level2RightLeft: { 
                    node: { x: 520, y: 210, text: "[3]" },
                    state: step >= 3 ? 'visible' : 'hidden',
                    link: { source: { x: 600, y: 130 }, target: { x: 520, y: 210 } },
                    arrow: step >= 3 && step < 7 ? 'dividing' : (step >= 7 ? 'merging' : 'hidden')
                },
                level2RightRight: { 
                    node: { x: 680, y: 210, text: "[9]" },
                    state: step >= 3 ? 'visible' : 'hidden',
                    link: { source: { x: 600, y: 130 }, target: { x: 680, y: 210 } },
                    arrow: step >= 3 && step < 7 ? 'dividing' : (step >= 7 ? 'merging' : 'hidden')
                },
                level3LeftRightLeft: { 
                    node: { x: 350, y: 290, text: "[27]" },
                    state: step >= 4 ? 'visible' : 'hidden',
                    link: { source: { x: 400, y: 210 }, target: { x: 350, y: 290 } },
                    arrow: step >= 4 && step < 5 ? 'dividing' : (step >= 5 ? 'merging' : 'hidden')
                },
                level3LeftRightRight: { 
                    node: { x: 450, y: 290, text: "[43]" },
                    state: step >= 4 ? 'visible' : 'hidden',
                    link: { source: { x: 400, y: 210 }, target: { x: 450, y: 290 } },
                    arrow: step >= 4 && step < 5 ? 'dividing' : (step >= 5 ? 'merging' : 'hidden')
                }
            };
            
            // Highlight nodes based on the current step
            if (step === 1) {
                treeData.level0.highlight = true;
            } else if (step === 2) {
                treeData.level1Left.highlight = true;
            } else if (step === 3) {
                treeData.level1Right.highlight = true;
            } else if (step === 4) {
                treeData.level2LeftRight.highlight = true;
            } else if (step === 5) {
                treeData.level3LeftRightLeft.highlight = true;
                treeData.level3LeftRightRight.highlight = true;
                treeData.level2LeftRight.merged = true;
                treeData.level2LeftRight.node.text = "[27, 43]";
            } else if (step === 6) {
                treeData.level2LeftLeft.highlight = true;
                treeData.level2LeftRight.highlight = true;
                treeData.level1Left.merged = true;
                treeData.level1Left.node.text = "[27, 38, 43]";
            } else if (step === 7) {
                treeData.level2RightLeft.highlight = true;
                treeData.level2RightRight.highlight = true;
                treeData.level1Right.merged = true;
                treeData.level1Right.node.text = "[3, 9]";
            } else if (step === 8) {
                treeData.level1Left.highlight = true;
                treeData.level1Right.highlight = true;
                treeData.level0.merged = true;
                treeData.level0.node.text = "[3, 9, 27, 38, 43]";
            }
            
            // Draw connections (links) first so they appear behind nodes
            Object.values(treeData).forEach(item => {
                if (item.state === 'visible' && item.link) {
                    const link = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    link.setAttribute('x1', item.link.source.x);
                    link.setAttribute('y1', item.link.source.y);
                    link.setAttribute('x2', item.link.target.x);
                    link.setAttribute('y2', item.link.target.y);
                    link.setAttribute('class', 'link');
                    
                    if (item.arrow === 'dividing') {
                        link.classList.add('dividing');
                        
                        // Add down arrow
                        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        const arrowX = item.link.target.x;
                        const arrowY = item.link.target.y - 15;
                        arrow.setAttribute('points', `${arrowX},${arrowY} ${arrowX-5},${arrowY-10} ${arrowX+5},${arrowY-10}`);
                        arrow.setAttribute('class', 'arrow');
                        arrow.style.fill = '#ff6600';
                        svg.appendChild(arrow);
                    } else if (item.arrow === 'merging') {
                        link.classList.add('merging');
                        
                        // Add up arrow
                        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        const arrowX = item.link.source.x;
                        const arrowY = item.link.source.y + 15;
                        arrow.setAttribute('points', `${arrowX},${arrowY} ${arrowX-5},${arrowY+10} ${arrowX+5},${arrowY+10}`);
                        arrow.setAttribute('class', 'arrow');
                        arrow.style.fill = '#2e8b57';
                        svg.appendChild(arrow);
                    }
                    
                    svg.appendChild(link);
                }
            });
            
            // Draw nodes
            Object.values(treeData).forEach(item => {
                if (item.state === 'visible') {
                    const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    nodeGroup.setAttribute('class', 'node');
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', item.node.x);
                    circle.setAttribute('cy', item.node.y);
                    circle.setAttribute('r', 30);
                    
                    if (item.highlight) circle.classList.add('highlight');
                    if (item.merged) circle.classList.add('merged');
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', item.node.x);
                    text.setAttribute('y', item.node.y);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('alignment-baseline', 'middle');
                    text.textContent = item.node.text;
                    
                    if (item.highlight) text.classList.add('highlight-text');
                    if (item.merged) text.classList.add('merged-text');
                    
                    nodeGroup.appendChild(circle);
                    nodeGroup.appendChild(text);
                    svg.appendChild(nodeGroup);
                }
            });
        }
    </script>
</body>
</html>